-- BatHUB Script - Versão Mobile Otimizada
-- Serviços principais
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local Workspace = workspace

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Detectar se é dispositivo móvel
local function isMobile()
    return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
end

-- Gerenciador de Conexões - Evita memory leaks
local ConnectionManager = {
    connections = {},
    add = function(self, name, connection)
        if self.connections[name] then
            self.connections[name]:Disconnect()
        end
        self.connections[name] = connection
    end,
    remove = function(self, name)
        if self.connections[name] then
            self.connections[name]:Disconnect()
            self.connections[name] = nil
        end
    end,
    cleanup = function(self)
        for _, connection in pairs(self.connections) do
            connection:Disconnect()
        end
        self.connections = {}
    end
}

-- Gerenciador de Estado - Substitui variáveis globais
local StateManager = {
    floatV1 = false,
    floatV2 = false,
    bestESP = false,
    set = function(self, key, value)
        self[key] = value
    end,
    get = function(self, key)
        return self[key]
    end
}

-- Sistema de Cache - Otimiza FindFirstChild repetitivos
local Cache = {
    instances = {},
    get = function(self, parent, name)
        if not parent then return nil end
        local key = tostring(parent) .. ":" .. name
        if not self.instances[key] then
            self.instances[key] = parent:FindFirstChild(name)
        end
        return self.instances[key]
    end,
    clear = function(self)
        self.instances = {}
    end
}

-- Configurações principais
local Settings = {
    Speed = {enabled = false, value = 50},
    Jump = {enabled = false, value = 90},
    FloatV1 = {enabled = false}, 
    FloatV2 = {enabled = false}, 
    ESP = {enabled = false, color = Color3.fromRGB(255, 100, 255), highlights = {}, nametags = {}},
    ESPBetter = {enabled = false}
}

-- Paleta de cores para ESP - NOMES CURTOS PARA CABER
local ColorPalette = {
    {name = "Verm", color = Color3.fromRGB(255, 80, 80)},
    {name = "Verde", color = Color3.fromRGB(80, 255, 80)},
    {name = "Azul", color = Color3.fromRGB(80, 120, 255)},
    {name = "Amar", color = Color3.fromRGB(255, 255, 80)},
    {name = "Roxo", color = Color3.fromRGB(255, 80, 255)},
    {name = "Lara", color = Color3.fromRGB(255, 165, 80)},
    {name = "Marr", color = Color3.fromRGB(165, 100, 80)},
    {name = "Bran", color = Color3.fromRGB(255, 255, 255)},
    {name = "Pret", color = Color3.fromRGB(40, 40, 40)},
    {name = "Rosa", color = Color3.fromRGB(255, 192, 203)},
    {name = "Cian", color = Color3.fromRGB(80, 255, 255)},
    {name = "Viol", color = Color3.fromRGB(138, 43, 226)}
}

-- Configurações padrão para reset
local DefaultSettings = {
    Speed = {enabled = false, value = 50},
    Jump = {enabled = false, value = 90},
    FloatV1 = {enabled = false},
    FloatV2 = {enabled = false},
    ESP = {enabled = false, color = Color3.fromRGB(255, 100, 255)},
    ESPBetter = {enabled = false}
}

local CONFIG_FILE_NAME = "BatHUB_Config.json"

-- Função otimizada para parsear valores monetários
local function parseValue(text)
    if not text or text == "" then return 0 end
    
    local multipliers = {Q = 1e15, T = 1e12, B = 1e9, M = 1e6, K = 1e3}
    local number, suffix = text:match("([%d%.]+)([QTBMK]?)")
    number = tonumber(number) or 0
    
    return multipliers[suffix] and number * multipliers[suffix] or number
end

-- Variáveis do ESP Better
local currentESP = nil
local highlights = {}

-- ESP Better - Otimizado para 10 FPS ao invés de 60 FPS
local function setupESPBetter()
    ConnectionManager:remove("ESPBetter")
    StateManager:set("bestESP", Settings.ESPBetter.enabled)
    
    if Settings.ESPBetter.enabled then
        local lastUpdate, UPDATE_INTERVAL = 0, 0.1
        
        ConnectionManager:add("ESPBetter", RunService.Heartbeat:Connect(function()
            local currentTime = tick()
            if currentTime - lastUpdate < UPDATE_INTERVAL or not StateManager:get("bestESP") then 
                return 
            end
            lastUpdate = currentTime

            local bestAnimal, bestValue, bestBase = nil, -math.huge, nil

            for _, plot in ipairs(Workspace.Plots:GetChildren()) do
                local plotSign = Cache:get(plot, "PlotSign")
                if plotSign then
                    local surfaceGui = Cache:get(plotSign, "SurfaceGui")
                    local frame = surfaceGui and Cache:get(surfaceGui, "Frame")
                    local textLabel = frame and Cache:get(frame, "TextLabel")
                    
                    if textLabel and textLabel.Text ~= "Empty Base" and not textLabel.Text:find(LocalPlayer.DisplayName) then
                        local animalPodiums = Cache:get(plot, "AnimalPodiums")
                        if animalPodiums then
                            for _, podium in ipairs(animalPodiums:GetChildren()) do
                                local base = Cache:get(podium, "Base")
                                local spawn = base and Cache:get(base, "Spawn")
                                local attach = spawn and Cache:get(spawn, "Attachment")
                                
                                if attach then
                                    local overhead = Cache:get(attach, "AnimalOverhead")
                                    if overhead then
                                        local stolen = Cache:get(overhead, "Stolen")
                                        if not (stolen and (stolen.Text == "FUSING" or stolen.Text == "IN MACHINE" or stolen.Text == "CRAFTING")) then
                                            local gen = Cache:get(overhead, "Generation")
                                            local rarity = Cache:get(overhead, "Rarity")
                                            local name = Cache:get(overhead, "DisplayName")
                                            
                                            if gen and rarity and name then
                                                local value = parseValue(gen.Text)
                                                if value > bestValue then
                                                    bestValue = value
                                                    bestAnimal = {
                                                        attachment = attach, 
                                                        nome = name.Text, 
                                                        raridade = rarity.Text, 
                                                        porSegundo = gen.Text
                                                    }
                                                    bestBase = base
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end

            -- Limpar ESP anterior
            if currentESP then 
                currentESP:Destroy() 
                currentESP = nil 
            end
            for _, hl in pairs(highlights) do 
                if hl and hl.Parent then hl:Destroy() end
            end
            highlights = {}

            -- Criar novo ESP se encontrou melhor animal
            if bestAnimal then
                local billboard = Instance.new("BillboardGui")
                billboard.Name = "BestAnimalESP"
                billboard.AlwaysOnTop = true
                billboard.Size = UDim2.new(0.35, 0, 0.65, 0)
                billboard.StudsOffset = Vector3.new(0, 3.2, 0)
                billboard.Parent = bestAnimal.attachment
                
                local back = Instance.new("Frame")
                back.BackgroundTransparency = 0.18
                back.BackgroundColor3 = Color3.fromRGB(24, 26, 34)
                back.Size = UDim2.new(1, 0, 1, 0)
                back.Position = UDim2.new(0.5, 0, 0.5, 0)
                back.AnchorPoint = Vector2.new(0.5, 0.5)
                back.Parent = billboard
                
                local uicorner = Instance.new("UICorner")
                uicorner.CornerRadius = UDim.new(0, 10)
                uicorner.Parent = back
                
                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(0.9, 0, 0.9, 0)
                textLabel.Position = UDim2.new(0.05, 0, 0.05, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.TextColor3 = Color3.new(1, 1, 0)
                textLabel.TextScaled = true
                textLabel.Font = Enum.Font.GothamBold
                textLabel.Text = string.format("%s | %s | %s", bestAnimal.nome, bestAnimal.raridade, bestAnimal.porSegundo)
                textLabel.TextWrapped = true
                textLabel.Parent = back
                
                currentESP = billboard

                -- Destacar decorações
                local decorations = bestBase and Cache:get(bestBase, "Decorations")
                if decorations then
                    for _, d in ipairs(decorations:GetDescendants()) do
                        local hl = Instance.new("Highlight")
                        hl.Name = "ESP_Deco"
                        hl.FillColor = Color3.fromRGB(0, 100, 255)
                        hl.OutlineColor = Color3.fromRGB(0, 60, 200)
                        hl.FillTransparency = 0
                        hl.Parent = d
                        highlights[d] = hl
                    end
                end
            end
        end))
    else
        -- Limpar ESP quando desabilitado
        if currentESP then
            currentESP:Destroy()
            currentESP = nil
        end
        for _, hl in pairs(highlights) do 
            if hl and hl.Parent then hl:Destroy() end
        end
        highlights = {}
    end
end

-- Sistema de ESP Players
local function setupESPPlayers()
    ConnectionManager:remove("ESPPlayers")
    
    -- Limpar ESP existente
    for _, highlight in pairs(Settings.ESP.highlights) do
        if highlight and highlight.Parent then highlight:Destroy() end
    end
    for _, nametag in pairs(Settings.ESP.nametags) do
        if nametag and nametag.Parent then nametag:Destroy() end
    end
    Settings.ESP.highlights = {}
    Settings.ESP.nametags = {}
    
    if Settings.ESP.enabled then
        local function createPlayerESP(player)
            if player == LocalPlayer then return end
            
            local function addESP()
                local character = player.Character
                if not character then return end
                
                local humanoidRootPart = Cache:get(character, "HumanoidRootPart")
                local humanoid = Cache:get(character, "Humanoid")
                if not (humanoidRootPart and humanoid) then return end
                
                -- Criar highlight
                local highlight = Instance.new("Highlight")
                highlight.Name = "PlayerESP"
                highlight.FillColor = Settings.ESP.color
                highlight.OutlineColor = Settings.ESP.color
                highlight.FillTransparency = 0.5
                highlight.OutlineTransparency = 0
                highlight.Parent = character
                Settings.ESP.highlights[player] = highlight
                
                -- Criar nametag
                local billboard = Instance.new("BillboardGui")
                billboard.Name = "PlayerNameTag"
                billboard.AlwaysOnTop = true
                billboard.Size = UDim2.new(0, 200, 0, 50)
                billboard.StudsOffset = Vector3.new(0, 3, 0)
                billboard.Parent = humanoidRootPart
                
                local nameLabel = Instance.new("TextLabel")
                nameLabel.Size = UDim2.new(1, 0, 1, 0)
                nameLabel.BackgroundTransparency = 1
                nameLabel.Text = player.DisplayName
                nameLabel.TextColor3 = Settings.ESP.color
                nameLabel.TextSize = 18
                nameLabel.Font = Enum.Font.GothamBold
                nameLabel.TextStrokeTransparency = 0
                nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
                nameLabel.Parent = billboard
                
                Settings.ESP.nametags[player] = billboard
            end
            
            if player.Character then
                addESP()
            end
            
            player.CharacterAdded:Connect(addESP)
        end
        
        -- Adicionar ESP para jogadores existentes
        for _, player in ipairs(Players:GetPlayers()) do
            createPlayerESP(player)
        end
        
        -- Adicionar ESP para novos jogadores
        ConnectionManager:add("ESPPlayers", Players.PlayerAdded:Connect(createPlayerESP))
        
        -- Remover ESP quando jogadores saem
        ConnectionManager:add("ESPPlayersRemoving", Players.PlayerRemoving:Connect(function(player)
            if Settings.ESP.highlights[player] then
                Settings.ESP.highlights[player]:Destroy()
                Settings.ESP.highlights[player] = nil
            end
            if Settings.ESP.nametags[player] then
                Settings.ESP.nametags[player]:Destroy()
                Settings.ESP.nametags[player] = nil
            end
        end))
    end
end

-- Sistema de configuração
local function saveConfig()
    local configToSave = {
        Speed = {enabled = Settings.Speed.enabled, value = Settings.Speed.value},
        Jump = {enabled = Settings.Jump.enabled, value = Settings.Jump.value},
        FloatV1 = {enabled = Settings.FloatV1.enabled},
        FloatV2 = {enabled = Settings.FloatV2.enabled},
        ESP = {enabled = Settings.ESP.enabled, color = {Settings.ESP.color.R, Settings.ESP.color.G, Settings.ESP.color.B}},
        ESPBetter = {enabled = Settings.ESPBetter.enabled}
    }
    
    local success, encoded = pcall(function()
        return HttpService:JSONEncode(configToSave)
    end)
    
    if success then
        writefile(CONFIG_FILE_NAME, encoded)
        return true
    end
    return false
end

local function loadConfig()
    if isfile(CONFIG_FILE_NAME) then
        local success, decoded = pcall(function()
            return HttpService:JSONDecode(readfile(CONFIG_FILE_NAME))
        end)
        
        if success and decoded then return decoded end
    end
    return nil
end

local function resetConfig()
    -- Restaurar configurações padrão
    for key, value in pairs(DefaultSettings) do
        Settings[key] = {}
        for subKey, subValue in pairs(value) do
            Settings[key][subKey] = subValue
        end
    end
    
    -- Limpar conexões
    ConnectionManager:cleanup()
    
    -- Limpar ESP Players
    for _, highlight in pairs(Settings.ESP.highlights) do
        if highlight and highlight.Parent then highlight:Destroy() end
    end
    for _, nametag in pairs(Settings.ESP.nametags) do
        if nametag and nametag.Parent then nametag:Destroy() end
    end
    Settings.ESP.highlights = {}
    Settings.ESP.nametags = {}
    
    -- Limpar ESP Better
    if currentESP then
        currentESP:Destroy()
        currentESP = nil
    end
    for _, hl in pairs(highlights) do 
        if hl and hl.Parent then hl:Destroy() end
    end
    highlights = {}
    
    -- Reset estados
    StateManager:set("floatV1", false)
    StateManager:set("floatV2", false)
    StateManager:set("bestESP", false)
    
    Cache:clear()
    return true
end

-- Função para UI responsiva PERFEITAMENTE PROPORCIONADA
local function getResponsiveSize()
    local viewport = Workspace.CurrentCamera.ViewportSize
    local mobile = isMobile()
    
    if mobile then
        -- TAMANHOS PERFEITAMENTE CALCULADOS PARA MOBILE
        local width = math.min(viewport.X * 0.70, 240) -- 240px max
        local height = math.min(viewport.Y * 0.55, 260) -- 260px max  
        return {width = width, height = height}
    else
        -- Desktop
        local isSmallScreen = viewport.X < 800 or viewport.Y < 600
        return isSmallScreen 
            and {width = math.min(viewport.X * 0.9, 350), height = math.min(viewport.Y * 0.85, 480)}
            or {width = 450, height = 580}
    end
end

-- Float V1 - Direção da câmera
local function setupFloatV1()
    ConnectionManager:remove("FloatV1")
    StateManager:set("floatV1", Settings.FloatV1.enabled)
    
    if Settings.FloatV1.enabled then
        ConnectionManager:add("FloatV1", RunService.Heartbeat:Connect(function()
            if not StateManager:get("floatV1") then return end
            
            local char = LocalPlayer.Character
            if not char then return end
            
            local hrp = Cache:get(char, "HumanoidRootPart")
            local cam = Workspace.CurrentCamera
            
            if hrp and cam then
                hrp.Velocity = cam.CFrame.LookVector * 25
            end
        end))
    end
end

-- Float V2 - Float aprimorado
local function setupFloatV2()
    ConnectionManager:remove("FloatV2")
    StateManager:set("floatV2", Settings.FloatV2.enabled)
    
    if Settings.FloatV2.enabled then
        ConnectionManager:add("FloatV2", RunService.Heartbeat:Connect(function()
            if not StateManager:get("floatV2") then return end
            
            local char = LocalPlayer.Character
            if not char then return end
            
            local hrp = Cache:get(char, "HumanoidRootPart")
            local humanoid = Cache:get(char, "Humanoid")
            local cam = Workspace.CurrentCamera
            
            if hrp and cam and humanoid then
                local moveVector = humanoid.MoveDirection
                if moveVector.Magnitude > 0 then
                    hrp.Velocity = (cam.CFrame.LookVector * moveVector.Z + cam.CFrame.RightVector * moveVector.X) * 30
                else
                    hrp.Velocity = Vector3.new(0, 0, 0)
                end
            end
        end))
    end
end

-- Limpar GUI existente
local function cleanupExistingGUI()
    local existingGUI = PlayerGui:FindFirstChild("BatHUBScriptGUI")
    if existingGUI then
        existingGUI:Destroy()
        task.wait(0.1)
    end
end

-- Criar Toggle com Slider PERFEITAMENTE PROPORCIONADO
local function createToggleAndSlider(parent, toggleText, sliderText, min, max, defaultValue, toggleCallback, sliderCallback)
    local mobile = isMobile()
    local containerHeight = mobile and 55 or 95 -- PROPORÇÃO PERFEITA
    
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, 0, 0, containerHeight)
    container.BackgroundColor3 = Color3.fromRGB(20, 10, 25)
    container.BorderSizePixel = 0
    container.Parent = parent

    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = UDim.new(0, 4)
    containerCorner.Parent = container

    local containerStroke = Instance.new("UIStroke")
    containerStroke.Color = Color3.fromRGB(138, 43, 226)
    containerStroke.Thickness = 1
    containerStroke.Parent = container

    -- Toggle superior PERFEITAMENTE PROPORCIONADO
    local toggle = Instance.new("Frame")
    toggle.Size = UDim2.new(1, -8, 0, mobile and 22 or 45)
    toggle.Position = UDim2.new(0, 4, 0, 2)
    toggle.BackgroundTransparency = 1
    toggle.Parent = container

    local toggleLabel = Instance.new("TextLabel")
    toggleLabel.Size = UDim2.new(0.45, 0, 1, 0) -- MENOR PARA CABER
    toggleLabel.BackgroundTransparency = 1
    toggleLabel.Text = toggleText
    toggleLabel.TextColor3 = Color3.fromRGB(200, 162, 255)
    toggleLabel.TextSize = mobile and 8 or 18
    toggleLabel.Font = Enum.Font.GothamBold
    toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
    toggleLabel.TextWrapped = true
    toggleLabel.TextScaled = mobile
    toggleLabel.Parent = toggle

    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0, mobile and 35 or 70, 0, mobile and 18 or 35)
    toggleButton.Position = UDim2.new(1, mobile and -38 or -75, 0, mobile and 2 or 5)
    toggleButton.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
    toggleButton.Text = "OFF"
    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleButton.TextSize = mobile and 7 or 14
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.BorderSizePixel = 0
    toggleButton.Parent = toggle

    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 9)
    toggleCorner.Parent = toggleButton

    local toggleGlow = Instance.new("UIStroke")
    toggleGlow.Color = Color3.fromRGB(150, 0, 0)
    toggleGlow.Thickness = 1
    toggleGlow.Transparency = 0.5
    toggleGlow.Parent = toggleButton

    -- Slider inferior PERFEITAMENTE PROPORCIONADO
    local slider = Instance.new("Frame")
    slider.Size = UDim2.new(1, -8, 0, mobile and 12 or 30)
    slider.Position = UDim2.new(0, 4, 0, mobile and 27 or 55)
    slider.BackgroundTransparency = 1
    slider.Parent = container

    local sliderLabel = Instance.new("TextLabel")
    sliderLabel.Size = UDim2.new(0.25, 0, 1, 0) -- MUITO MENOR
    sliderLabel.BackgroundTransparency = 1
    sliderLabel.Text = sliderText .. ": " .. tostring(defaultValue)
    sliderLabel.TextColor3 = Color3.fromRGB(180, 140, 230)
    sliderLabel.TextSize = mobile and 5 or 14
    sliderLabel.Font = Enum.Font.Gotham
    sliderLabel.TextXAlignment = Enum.TextXAlignment.Left
    sliderLabel.TextScaled = mobile
    sliderLabel.Parent = slider

    local sliderBar = Instance.new("Frame")
    sliderBar.Size = UDim2.new(0.70, 0, 0, mobile and 6 or 10) -- PROPORÇÃO PERFEITA
    sliderBar.Position = UDim2.new(0.28, 0, 0, mobile and 3 or 10)
    sliderBar.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    sliderBar.BorderSizePixel = 0
    sliderBar.Parent = slider

    local sliderFill = Instance.new("Frame")
    sliderFill.Size = UDim2.new((defaultValue - min) / (max - min), 0, 1, 0)
    sliderFill.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
    sliderFill.BorderSizePixel = 0
    sliderFill.Parent = sliderBar

    local sliderCorner = Instance.new("UICorner")
    sliderCorner.CornerRadius = UDim.new(0, 3)
    sliderCorner.Parent = sliderBar

    local sliderFillCorner = Instance.new("UICorner")
    sliderFillCorner.CornerRadius = UDim.new(0, 3)
    sliderFillCorner.Parent = sliderFill

    local sliderThumb = Instance.new("Frame")
    sliderThumb.Size = UDim2.new(0, mobile and 10 or 16, 0, mobile and 10 or 16)
    sliderThumb.Position = UDim2.new((defaultValue - min) / (max - min), -5, 0, -2)
    sliderThumb.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    sliderThumb.BorderSizePixel = 0
    sliderThumb.Parent = sliderBar

    local thumbCorner = Instance.new("UICorner")
    thumbCorner.CornerRadius = UDim.new(0, 5)
    thumbCorner.Parent = sliderThumb

    local sliderButton = Instance.new("TextButton")
    sliderButton.Size = UDim2.new(1, 0, 1, 10)
    sliderButton.Position = UDim2.new(0, 0, 0, -5)
    sliderButton.BackgroundTransparency = 1
    sliderButton.Text = ""
    sliderButton.Parent = sliderBar

    -- Lógica do slider com suporte a touch
    local dragging = false
    local isEnabled = false
    local currentValue = defaultValue

    local function updateSlider(position)
        local relativeX = math.clamp((position.X - sliderBar.AbsolutePosition.X) / sliderBar.AbsoluteSize.X, 0, 1)
        currentValue = math.floor(min + (max - min) * relativeX)
        sliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
        sliderThumb.Position = UDim2.new(relativeX, -5, 0, -2)
        sliderLabel.Text = sliderText .. ": " .. tostring(currentValue)
        if sliderCallback then sliderCallback(currentValue) end
    end

    -- Touch e mouse support
    sliderButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            updateSlider(input.Position)
        end
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateSlider(input.Position)
        end
    end)

    -- Lógica do toggle
    toggleButton.MouseButton1Click:Connect(function()
        isEnabled = not isEnabled
        local newColor = isEnabled and Color3.fromRGB(0, 150, 0) or Color3.fromRGB(150, 0, 0)
        
        TweenService:Create(toggleButton, TweenInfo.new(0.3, Enum.EasingStyle.Quart), {
            BackgroundColor3 = newColor
        }):Play()
        
        TweenService:Create(toggleGlow, TweenInfo.new(0.3, Enum.EasingStyle.Quart), {
            Color = newColor
        }):Play()
        
        toggleButton.Text = isEnabled and "ON" or "OFF"
        if toggleCallback then toggleCallback(isEnabled) end
    end)

    return container
end

-- Criar Toggle simples PERFEITAMENTE PROPORCIONADO
local function createToggleOnly(parent, toggleText, toggleCallback)
    local mobile = isMobile()
    
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, 0, 0, mobile and 26 or 60) -- PROPORÇÃO PERFEITA
    container.BackgroundColor3 = Color3.fromRGB(20, 10, 25)
    container.BorderSizePixel = 0
    container.Parent = parent

    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = UDim.new(0, 4)
    containerCorner.Parent = container

    local containerStroke = Instance.new("UIStroke")
    containerStroke.Color = Color3.fromRGB(138, 43, 226)
    containerStroke.Thickness = 1
    containerStroke.Parent = container

    local toggle = Instance.new("Frame")
    toggle.Size = UDim2.new(1, -8, 0, mobile and 18 or 40)
    toggle.Position = UDim2.new(0, 4, 0, mobile and 4 or 10)
    toggle.BackgroundTransparency = 1
    toggle.Parent = container

    local toggleLabel = Instance.new("TextLabel")
    toggleLabel.Size = UDim2.new(0.45, 0, 1, 0) -- MENOR PARA CABER 
    toggleLabel.BackgroundTransparency = 1
    toggleLabel.Text = toggleText
    toggleLabel.TextColor3 = Color3.fromRGB(200, 162, 255)
    toggleLabel.TextSize = mobile and 8 or 18
    toggleLabel.Font = Enum.Font.GothamBold
    toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
    toggleLabel.TextWrapped = true
    toggleLabel.TextScaled = mobile
    toggleLabel.Parent = toggle

    local toggleButton = Instance.new("TextButton")
    toggleButton.Size = UDim2.new(0, mobile and 35 or 70, 0, mobile and 18 or 35)
    toggleButton.Position = UDim2.new(1, mobile and -38 or -75, 0, mobile and 0 or 2.5)
    toggleButton.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
    toggleButton.Text = "OFF"
    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleButton.TextSize = mobile and 7 or 14
    toggleButton.Font = Enum.Font.GothamBold
    toggleButton.BorderSizePixel = 0
    toggleButton.Parent = toggle

    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 9)
    toggleCorner.Parent = toggleButton

    local toggleGlow = Instance.new("UIStroke")
    toggleGlow.Color = Color3.fromRGB(150, 0, 0)
    toggleGlow.Thickness = 1
    toggleGlow.Transparency = 0.5
    toggleGlow.Parent = toggleButton

    local isEnabled = false

    toggleButton.MouseButton1Click:Connect(function()
        isEnabled = not isEnabled
        local newColor = isEnabled and Color3.fromRGB(0, 150, 0) or Color3.fromRGB(150, 0, 0)
        
        TweenService:Create(toggleButton, TweenInfo.new(0.3, Enum.EasingStyle.Quart), {
            BackgroundColor3 = newColor
        }):Play()
        
        TweenService:Create(toggleGlow, TweenInfo.new(0.3, Enum.EasingStyle.Quart), {
            Color = newColor
        }):Play()
        
        toggleButton.Text = isEnabled and "ON" or "OFF"
        if toggleCallback then toggleCallback(isEnabled) end
    end)

    return container
end

-- Criar botão de cor PERFEITAMENTE PROPORCIONADO
local function createColorButton(parent, colorData, callback)
    local mobile = isMobile()
    
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, mobile and 58 or 110, 0, mobile and 18 or 35) -- PROPORÇÃO PERFEITA
    button.BackgroundColor3 = colorData.color
    button.Text = colorData.name
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = mobile and 5 or 12
    button.Font = Enum.Font.GothamBold
    button.BorderSizePixel = 0
    button.Parent = parent

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 3)
    corner.Parent = button

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(200, 162, 255)
    stroke.Thickness = 1
    stroke.Transparency = 1
    stroke.Parent = button

    button.MouseButton1Click:Connect(function()
        if callback then callback(colorData.color) end
        
        TweenService:Create(stroke, TweenInfo.new(0.3, Enum.EasingStyle.Quart), {
            Transparency = 0
        }):Play()
        
        task.spawn(function()
            task.wait(0.3)
            TweenService:Create(stroke, TweenInfo.new(0.3, Enum.EasingStyle.Quart), {
                Transparency = 1
            }):Play()
        end)
    end)

    return button
end

-- Sistema de Drag Universal (PC e Mobile)
local function setupUniversalDrag(frame, dragTarget)
    local dragging = false
    local dragStart = nil
    local startPos = nil

    local function startDrag(input)
        dragging = true
        dragStart = input.Position
        startPos = frame.Position
    end

    local function updateDrag(input)
        if dragging then
            local delta = input.Position - dragStart
            local viewport = Workspace.CurrentCamera.ViewportSize
            local newPos = UDim2.new(
                0, math.clamp(startPos.X.Offset + delta.X, 0, viewport.X - frame.AbsoluteSize.X),
                0, math.clamp(startPos.Y.Offset + delta.Y, 0, viewport.Y - frame.AbsoluteSize.Y)
            )
            frame.Position = newPos
        end
    end

    local function stopDrag()
        dragging = false
    end

    -- Eventos do target
    dragTarget.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            startDrag(input)
        end
    end)

    dragTarget.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            updateDrag(input)
        end
    end)

    dragTarget.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            stopDrag()
        end
    end)

    -- Eventos globais
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            updateDrag(input)
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            stopDrag()
        end
    end)
end

-- SISTEMA DE SCROLL TOUCH NATIVO PARA MOBILE
local function setupTouchScroll(scrollFrame)
    if not isMobile() then return end
    
    local lastTouchPos = nil
    local touchScrolling = false
    
    scrollFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch then
            lastTouchPos = input.Position
            touchScrolling = true
        end
    end)
    
    scrollFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch and touchScrolling and lastTouchPos then
            local delta = input.Position - lastTouchPos
            local newCanvasPos = scrollFrame.CanvasPosition - Vector2.new(0, delta.Y)
            newCanvasPos = Vector2.new(0, math.clamp(newCanvasPos.Y, 0, math.max(0, scrollFrame.AbsoluteCanvasSize.Y - scrollFrame.AbsoluteSize.Y)))
            scrollFrame.CanvasPosition = newCanvasPos
            lastTouchPos = input.Position
        end
    end)
    
    scrollFrame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.Touch then
            touchScrolling = false
            lastTouchPos = nil
        end
    end)
end

-- Função principal para criar UI PERFEITAMENTE PROPORCIONADA
local function createUI()
    cleanupExistingGUI()

    local responsiveSize = getResponsiveSize()
    local mobile = isMobile()
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "BatHUBScriptGUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = PlayerGui

    -- Frame principal PERFEITAMENTE PROPORCIONADO
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, responsiveSize.width, 0, responsiveSize.height)
    mainFrame.Position = UDim2.new(0.5, -responsiveSize.width/2, 0.5, -responsiveSize.height/2)
    mainFrame.BackgroundColor3 = Color3.fromRGB(15, 5, 20)
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.Parent = screenGui

    -- Decorações do frame principal
    local mainCorner = Instance.new("UICorner")
    mainCorner.CornerRadius = UDim.new(0, mobile and 6 or 16)
    mainCorner.Parent = mainFrame

    local mainStroke = Instance.new("UIStroke")
    mainStroke.Color = Color3.fromRGB(138, 43, 226)
    mainStroke.Thickness = mobile and 1 or 2
    mainStroke.Transparency = 0.3
    mainStroke.Parent = mainFrame

    local mainGradient = Instance.new("UIGradient")
    mainGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 10, 35)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
    }
    mainGradient.Rotation = 45
    mainGradient.Parent = mainFrame

    -- Barra de título PERFEITAMENTE PROPORCIONADA
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, mobile and 22 or 60) -- PROPORÇÃO PERFEITA
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 0, 40)
    titleBar.BorderSizePixel = 0
    titleBar.Active = true
    titleBar.Parent = mainFrame

    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, mobile and 6 or 16)
    titleCorner.Parent = titleBar

    local titleGradient = Instance.new("UIGradient")
    titleGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(138, 43, 226)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(60, 20, 80))
    }
    titleGradient.Rotation = 90
    titleGradient.Parent = titleBar

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, mobile and -25 or -70, 1, 0)
    titleLabel.Position = UDim2.new(0, mobile and 5 or 20, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "🦇 BatHUB 🦇"
    titleLabel.TextColor3 = Color3.fromRGB(200, 162, 255)
    titleLabel.TextSize = mobile and 9 or 24
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.TextScaled = mobile
    titleLabel.Parent = titleBar

    -- Botão fechar PERFEITAMENTE PROPORCIONADO
    local closeBtn = Instance.new("TextButton")
    closeBtn.Size = UDim2.new(0, mobile and 18 or 40, 0, mobile and 18 or 40)
    closeBtn.Position = UDim2.new(1, mobile and -20 or -50, 0, mobile and 2 or 10)
    closeBtn.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
    closeBtn.Text = "×"
    closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeBtn.TextSize = mobile and 10 or 24
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.BorderSizePixel = 0
    closeBtn.Parent = titleBar

    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, mobile and 9 or 20)
    closeCorner.Parent = closeBtn

    -- UI minimizada MAIOR COMO SOLICITADO
    local minimizedFrame = Instance.new("Frame")
    minimizedFrame.Name = "MinimizedFrame"  
    minimizedFrame.Size = UDim2.new(0, mobile and 50 or 60, 0, mobile and 50 or 60) -- MAIOR
    minimizedFrame.Position = UDim2.new(0, 20, 0, 20)
    minimizedFrame.BackgroundColor3 = Color3.fromRGB(30, 0, 40)
    minimizedFrame.Visible = false
    minimizedFrame.Active = true
    minimizedFrame.Parent = screenGui

    local miniCorner = Instance.new("UICorner")
    miniCorner.CornerRadius = UDim.new(0, mobile and 12 or 15)
    miniCorner.Parent = minimizedFrame

    local miniStroke = Instance.new("UIStroke")
    miniStroke.Color = Color3.fromRGB(138, 43, 226)
    miniStroke.Thickness = 2
    miniStroke.Parent = minimizedFrame

    local miniLabel = Instance.new("TextLabel")
    miniLabel.Size = UDim2.new(1, 0, 1, 0)
    miniLabel.BackgroundTransparency = 1
    miniLabel.Text = "🌙"
    miniLabel.TextColor3 = Color3.fromRGB(200, 162, 255)
    miniLabel.TextSize = mobile and 24 or 28 -- MAIOR
    miniLabel.Font = Enum.Font.GothamBold
    miniLabel.Parent = minimizedFrame

    -- Setup drag universal
    setupUniversalDrag(mainFrame, titleBar)
    
    -- Drag para UI minimizada com sistema de clique/drag aprimorado
    local miniDragging = false
    local miniClickStart = 0
    local miniClickThreshold = 0.3

    local function setupMinimizedInteraction()
        minimizedFrame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                miniClickStart = tick()
                miniDragging = false
            end
        end)

        minimizedFrame.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                local clickDuration = tick() - miniClickStart
                
                if clickDuration < miniClickThreshold and not miniDragging then
                    -- Clique rápido = expandir UI
                    minimizedFrame.Visible = false
                    mainFrame.Visible = true
                    
                    -- Animação suave de expansão
                    mainFrame.Size = UDim2.new(0, 0, 0, 0)
                    mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
                    
                    local expandTween = TweenService:Create(mainFrame, TweenInfo.new(0.4, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                        Size = UDim2.new(0, responsiveSize.width, 0, responsiveSize.height),
                        Position = UDim2.new(0.5, -responsiveSize.width/2, 0.5, -responsiveSize.height/2)
                    })
                    expandTween:Play()
                end
            end
        end)
    end

    setupMinimizedInteraction()
    setupUniversalDrag(minimizedFrame, minimizedFrame)

    -- Container principal PERFEITAMENTE PROPORCIONADO PARA SCROLL
    local containerTop = mobile and 40 or 130
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1, -10, 1, containerTop + 12) -- PROPORÇÃO PERFEITA
    container.Position = UDim2.new(0, 5, 0, containerTop)
    container.BackgroundTransparency = 1
    container.Parent = mainFrame

    -- Sistema de abas PERFEITAMENTE PROPORCIONADO
    local tabButtons = Instance.new("Frame")
    tabButtons.Size = UDim2.new(1, -10, 0, mobile and 18 or 45)
    tabButtons.Position = UDim2.new(0, 5, 0, mobile and 25 or 75)
    tabButtons.BackgroundTransparency = 1
    tabButtons.Parent = mainFrame

    local tabLayout = Instance.new("UIListLayout")
    tabLayout.FillDirection = Enum.FillDirection.Horizontal
    tabLayout.Padding = UDim.new(0, mobile and 2 or 15)
    tabLayout.Parent = tabButtons

    local function createTab(name, text)
        local tabBtn = Instance.new("TextButton")
        tabBtn.Size = UDim2.new(0, mobile and 70 or 120, 1, 0) -- PROPORÇÃO PERFEITA
        tabBtn.BackgroundColor3 = Color3.fromRGB(40, 10, 50)
        tabBtn.BorderSizePixel = 0
        tabBtn.Text = text
        tabBtn.TextColor3 = Color3.fromRGB(180, 140, 230)
        tabBtn.Font = Enum.Font.GothamBold
        tabBtn.TextSize = mobile and 6 or 16
        tabBtn.TextScaled = mobile
        tabBtn.Parent = tabButtons

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, mobile and 4 or 10)
        corner.Parent = tabBtn

        local stroke = Instance.new("UIStroke")
        stroke.Color = Color3.fromRGB(100, 40, 130)
        stroke.Thickness = 1
        stroke.Parent = tabBtn

        return tabBtn
    end

    local playerTab = createTab("Player", "👤 Player")
    local helperTab = createTab("Helper", "📍 Helper")  
    local configTab = createTab("Config", "⚙️ Config")

    -- FUNÇÃO PARA CRIAR SEÇÃO COM SCROLL FUNCIONAL E TOUCH
    local function createSection(name)
        local section = Instance.new("ScrollingFrame")
        section.Name = name .. "Section"
        section.Size = UDim2.new(1, 0, 1, 0)
        section.Position = UDim2.new(0, 0, 0, 0)
        section.BackgroundTransparency = 1
        section.BorderSizePixel = 0
        section.Visible = false
        -- CONFIGURAÇÕES CRÍTICAS PARA SCROLL APARECER E FUNCIONAR
        section.ScrollBarThickness = mobile and 12 or 6
        section.ScrollBarImageColor3 = Color3.fromRGB(138, 43, 226)
        section.ScrollBarImageTransparency = 0 -- CRUCIAL: 0 PARA APARECER
        section.ScrollingDirection = Enum.ScrollingDirection.Y
        section.ScrollingEnabled = true
        section.CanvasSize = UDim2.new(0, 0, 0, 0) -- ZERADO - IMPORTANTE
        section.AutomaticCanvasSize = Enum.AutomaticSize.Y -- AUTOMÁTICO - CRUCIAL
        -- IMAGENS DA SCROLLBAR PARA GARANTIR VISIBILIDADE
        section.TopImage = "rbxasset://textures/ui/Scroll/scroll-top.png"
        section.MidImage = "rbxasset://textures/ui/Scroll/scroll-middle.png"
        section.BottomImage = "rbxasset://textures/ui/Scroll/scroll-bottom.png"
        section.Parent = container

        local layout = Instance.new("UIListLayout")
        layout.Padding = UDim.new(0, mobile and 4 or 15)
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Parent = section

        -- PADDING INTERNO PARA SCROLL FUNCIONAR
        local padding = Instance.new("UIPadding")
        padding.PaddingTop = UDim.new(0, mobile and 4 or 10)
        padding.PaddingBottom = UDim.new(0, mobile and 8 or 10)
        padding.PaddingLeft = UDim.new(0, 0)
        padding.PaddingRight = UDim.new(0, mobile and 12 or 0) -- ESPAÇO PARA SCROLLBAR
        padding.Parent = section

        -- SETUP TOUCH SCROLL NATIVO
        setupTouchScroll(section)

        return section
    end

    local playerSection = createSection("Player")
    local helperSection = createSection("Helper")
    local configSection = createSection("Config")

    -- Mostrar primeira aba
    playerSection.Visible = true
    playerTab.BackgroundColor3 = Color3.fromRGB(100, 40, 130)

    -- Sistema de troca de abas
    local function switchTab(targetSection, targetBtn)
        playerSection.Visible = false
        helperSection.Visible = false
        configSection.Visible = false
        
        playerTab.BackgroundColor3 = Color3.fromRGB(40, 10, 50)
        helperTab.BackgroundColor3 = Color3.fromRGB(40, 10, 50)
        configTab.BackgroundColor3 = Color3.fromRGB(40, 10, 50)
        
        targetSection.Visible = true
        targetBtn.BackgroundColor3 = Color3.fromRGB(100, 40, 130)
        
        -- Reset scroll para o topo
        targetSection.CanvasPosition = Vector2.new(0, 0)
    end

    playerTab.MouseButton1Click:Connect(function() switchTab(playerSection, playerTab) end)
    helperTab.MouseButton1Click:Connect(function() switchTab(helperSection, helperTab) end)
    configTab.MouseButton1Click:Connect(function() switchTab(configSection, configTab) end)

    -- Controles da seção Player PERFEITAMENTE PROPORCIONADOS
    createToggleAndSlider(playerSection, "🚀 Speed Hack", "Speed", 16, 100, 50,
        function(enabled)
            Settings.Speed.enabled = enabled
            ConnectionManager:remove("Speed")
            if enabled then
                ConnectionManager:add("Speed", RunService.Heartbeat:Connect(function()
                    local char = LocalPlayer.Character
                    if not char then return end
                    local humanoid = Cache:get(char, "Humanoid")
                    local rootPart = Cache:get(char, "HumanoidRootPart")
                    if humanoid and rootPart and humanoid.MoveDirection.Magnitude > 0 then
                        local velocity = humanoid.MoveDirection * Settings.Speed.value
                        rootPart.Velocity = Vector3.new(velocity.X, rootPart.Velocity.Y, velocity.Z)
                    end
                end))
            end
        end,
        function(value) Settings.Speed.value = value end
    )

    local canJump = true
    createToggleAndSlider(playerSection, "🦘 Jump Hack", "Jump Power", 50, 150, 90,
        function(enabled)
            Settings.Jump.enabled = enabled
            ConnectionManager:remove("Jump")
            if enabled then
                ConnectionManager:add("Jump", UserInputService.JumpRequest:Connect(function()
                    if not canJump then return end
                    local char = LocalPlayer.Character
                    if not char then return end
                    local rootPart = Cache:get(char, "HumanoidRootPart")
                    if rootPart then
                        canJump = false
                        rootPart.Velocity = Vector3.new(rootPart.Velocity.X, Settings.Jump.value, rootPart.Velocity.Z)
                        task.spawn(function()
                            task.wait(1.5)
                            canJump = true
                        end)
                    end
                end))
            end
        end,
        function(value) Settings.Jump.value = value end
    )

    createToggleOnly(playerSection, "🪶 Float V1 (Camera Direction)",
        function(enabled)
            Settings.FloatV1.enabled = enabled
            setupFloatV1()
        end
    )

    createToggleOnly(playerSection, "🎈 Float V2 (Enhanced)",
        function(enabled)
            Settings.FloatV2.enabled = enabled
            setupFloatV2()
        end
    )

    -- Controles da seção Helper PERFEITAMENTE PROPORCIONADOS
    createToggleOnly(helperSection, "🧠 ESP Best Brainrot",
        function(enabled)
            Settings.ESPBetter.enabled = enabled
            setupESPBetter()
        end
    )

    createToggleOnly(helperSection, "👁️ ESP Players",
        function(enabled)
            Settings.ESP.enabled = enabled
            setupESPPlayers()
        end
    )

    -- Seção de cores ESP PERFEITAMENTE PROPORCIONADA
    local colorFrame = Instance.new("Frame")
    colorFrame.Size = UDim2.new(1, -4, 0, mobile and 78 or 200) -- PROPORÇÃO PERFEITA
    colorFrame.BackgroundColor3 = Color3.fromRGB(20, 10, 25)
    colorFrame.BorderSizePixel = 0
    colorFrame.Parent = helperSection

    local colorFrameCorner = Instance.new("UICorner")
    colorFrameCorner.CornerRadius = UDim.new(0, 4)
    colorFrameCorner.Parent = colorFrame

    local colorStroke = Instance.new("UIStroke")
    colorStroke.Color = Color3.fromRGB(138, 43, 226)
    colorStroke.Thickness = 1
    colorStroke.Parent = colorFrame

    local colorTitle = Instance.new("TextLabel")
    colorTitle.Size = UDim2.new(1, -6, 0, mobile and 12 or 30)
    colorTitle.Position = UDim2.new(0, 3, 0, 3)
    colorTitle.BackgroundTransparency = 1
    colorTitle.Text = "🎨 ESP Colors"
    colorTitle.TextColor3 = Color3.fromRGB(200, 162, 255)
    colorTitle.TextSize = mobile and 8 or 18
    colorTitle.Font = Enum.Font.GothamBold
    colorTitle.TextXAlignment = Enum.TextXAlignment.Left
    colorTitle.TextScaled = mobile
    colorTitle.Parent = colorFrame

    local colorGrid = Instance.new("Frame")
    colorGrid.Size = UDim2.new(1, -8, 1, mobile and -16 or -40)
    colorGrid.Position = UDim2.new(0, 4, 0, mobile and 14 or 35)
    colorGrid.BackgroundTransparency = 1
    colorGrid.Parent = colorFrame

    local gridLayout = Instance.new("UIGridLayout")
    gridLayout.CellSize = UDim2.new(0, mobile and 58 or 110, 0, mobile and 18 or 35) -- PROPORÇÃO PERFEITA
    gridLayout.CellPadding = UDim2.new(0, mobile and 1 or 5, 0, mobile and 1 or 5)
    gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    gridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
    gridLayout.Parent = colorGrid

    for _, colorData in ipairs(ColorPalette) do
        createColorButton(colorGrid, colorData, function(color)
            Settings.ESP.color = color
            if Settings.ESP.enabled then
                for player, highlight in pairs(Settings.ESP.highlights) do
                    if highlight and highlight.Parent then
                        highlight.FillColor = color
                        highlight.OutlineColor = color
                    end
                end
                for player, nametag in pairs(Settings.ESP.nametags) do
                    if nametag and nametag.Parent then
                        local nameLabel = nametag:FindFirstChild("TextLabel")
                        if nameLabel then
                            nameLabel.TextColor3 = color
                        end
                    end
                end
            end
        end)
    end

    -- Controles da seção Config PERFEITAMENTE PROPORCIONADOS
    local configButtonsFrame = Instance.new("Frame")
    configButtonsFrame.Size = UDim2.new(1, 0, 0, mobile and 85 or 50)
    configButtonsFrame.BackgroundTransparency = 1
    configButtonsFrame.Parent = configSection

    local configLayout = Instance.new("UIListLayout")
    configLayout.FillDirection = mobile and Enum.FillDirection.Vertical or Enum.FillDirection.Horizontal
    configLayout.Padding = UDim.new(0, mobile and 4 or 20)
    configLayout.Parent = configButtonsFrame

    local function createConfigButton(text, color, callback)
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(0, mobile and 210 or 120, 0, mobile and 22 or 40) -- PROPORÇÃO PERFEITA
        btn.BackgroundColor3 = color
        btn.Text = text
        btn.TextColor3 = Color3.fromRGB(255, 255, 255)
        btn.TextSize = mobile and 9 or 16
        btn.Font = Enum.Font.GothamBold
        btn.BorderSizePixel = 0
        btn.Parent = configButtonsFrame

        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 4)
        corner.Parent = btn

        btn.MouseButton1Click:Connect(callback)
        return btn
    end

    -- BOTÕES COM CORES CORRETAS E TAMANHOS PERFEITOS
    local saveBtn = createConfigButton("💾 Salvar", Color3.fromRGB(0, 150, 0), function()
        task.spawn(function()
            local originalText = saveBtn.Text
            saveBtn.Text = saveConfig() and "✅ Salvo!" or "❌ Erro!"
            task.wait(2)
            saveBtn.Text = originalText
        end)
    end)

    local loadBtn = createConfigButton("📂 Carregar", Color3.fromRGB(0, 100, 200), function()
        task.spawn(function()
            local originalText = loadBtn.Text
            local config = loadConfig()
            if config then
                for key, value in pairs(config) do
                    if Settings[key] then
                        for subKey, subValue in pairs(value) do
                            if subKey == "color" and type(subValue) == "table" then
                                Settings[key][subKey] = Color3.fromRGB(subValue[1], subValue[2], subValue[3])
                            else
                                Settings[key][subKey] = subValue
                            end
                        end
                    end
                end
                loadBtn.Text = "✅ Carregado!"
            else
                loadBtn.Text = "❌ Erro!"
            end
            task.wait(2)
            loadBtn.Text = originalText
        end)
    end)

    local resetBtn = createConfigButton("🔄 Resetar", Color3.fromRGB(200, 0, 0), function()
        task.spawn(function()
            local originalText = resetBtn.Text
            resetBtn.Text = resetConfig() and "✅ Resetado!" or "❌ Erro!"
            task.wait(2)
            resetBtn.Text = originalText
        end)
    end)

    -- Botão fechar com animação aprimorada
    closeBtn.MouseButton1Click:Connect(function()
        local closeTween = TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
            Size = UDim2.new(0, 0, 0, 0),
            Position = UDim2.new(0.5, 0, 0.5, 0)
        })
        closeTween:Play()
        
        closeTween.Completed:Connect(function()
            mainFrame.Visible = false
            minimizedFrame.Visible = true
        end)
    end)
end

-- Cleanup completo
local function cleanup()
    ConnectionManager:cleanup()
    if currentESP then currentESP:Destroy() currentESP = nil end
    for _, hl in pairs(highlights) do if hl and hl.Parent then hl:Destroy() end end
    highlights = {}
    for _, highlight in pairs(Settings.ESP.highlights) do
        if highlight and highlight.Parent then highlight:Destroy() end
    end
    for _, nametag in pairs(Settings.ESP.nametags) do
        if nametag and nametag.Parent then nametag:Destroy() end
    end
    Settings.ESP.highlights = {}
    Settings.ESP.nametags = {}
    Cache:clear()
    StateManager:set("floatV1", false)
    StateManager:set("floatV2", false)
    StateManager:set("bestESP", false)
    cleanupExistingGUI()
end

-- Event cleanup
Players.PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then cleanup() end
end)

-- Inicializar
createUI()
